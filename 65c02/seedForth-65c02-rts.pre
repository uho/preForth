\ seedForth: machine dependent portion

\ interpreter and basic asm primitives are taken from preForth-65c02-rts.pre,
\ and then this file defines additional primitives (arithmetic, memory, etc)

pre
	.area	zpage

	.ds	3 ; extend temp from 3 to 6 locations for mul/div

	.area	text

;

\ aliases for the user-visible versions of some internal routines
pre
_enter = _nest
_exit = _unnest
;

\ note: we arrive at _dodoes by a sequence of 2 calls, the return
\ address stacked by first call points to some instance data, and
\ the return address stacked by second call (to _dodoes) points to
\ high level forth code which is going to operate on that instance
\ data -- move the first pushed address to data stack and "nest"
\ the second pushed address, adding 1 because of 65c02's jsr/rts
code dodoes ( -- )
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	ldx	rsp
	bne	1$
	dec	rsp+1
1$:	dec	rsp
	lda	ip+1
	sta	[rsp],y
	dec	rsp
	lda	ip
	sta	[rsp],y

	pla
	sta	ip
	pla
	sta	ip+1
	inc	ip
	bne	_dovar
	inc	ip+1
	; fall into dovar
;

\ note: arriving at _dovar, we just move one address to data stack
code dovar ( -- )
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	ldx	dsp
	bne	1$
	dec	dsp+1
1$:	dec	dsp
	dec	dsp

	pla
	sec
	adc	#0
	sta	[dsp],y
	pla
	adc	#0
	iny
	sta	[dsp],y
	dey

	bra	next1
;

code key? ( -- f )
	ldx	dsp
	bne	1$
	dec	dsp+1
1$:	dec	dsp
	lda	STDIN_STATUS
	beq	2$
	lda	#0xff
2$:	sta	[dsp],y
	dec	dsp
	lda	STDIN_STATUS
	sta	[dsp],y
	bra	next2
;

code or ( x1 x2 -- x3 )
	lda	[dsp],y
	ldy	#2
	ora	[dsp],y
	sta	[dsp],y
	dey
	lda	[dsp],y
	ldy	#3
	ora	[dsp],y
	sta	[dsp],y
	ldy	#0

	inc	dsp
	inc	dsp
	bne	next2
	inc	dsp+1
	bra	next2
;

code and ( x1 x2 -- x3 )
	lda	[dsp],y
	ldy	#2
	and	[dsp],y
	sta	[dsp],y
	dey
	lda	[dsp],y
	ldy	#3
	and	[dsp],y
	sta	[dsp],y
	ldy	#0

	inc	dsp
	inc	dsp
	bne	next2
	inc	dsp+1
	bra	next2
;

code @ ( addr -- x )
	lda	[dsp],y
	sta	temp
	iny
	lda	[dsp],y
	sta	temp+1

	lda	[temp],y
	sta	[dsp],y
	dey
	lda	[temp],y
	sta	[dsp],y

	bra	next2
;

code c@ ( c-addr -- c )
	lda	[dsp],y
	sta	temp
	iny
	lda	[dsp],y
	sta	temp+1

	lda	#0
	sta	[dsp],y
	dey
	lda	[temp],y
	sta	[dsp],y

	;bra	next2

next2:
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	lda	[ip],y
	sta	2$+1 ; self modifying code
	inc	ip
	bne	1$
	inc	ip+1
1$:	lda	[ip],y
	sta	2$+2 ; self modifying code
	inc	ip
	bne	2$
	inc	ip+1
2$:	jmp	0
;

code ! ( x addr -- )
	lda	[dsp],y
	sta	temp
	inc	dsp
	lda	[dsp],y
	sta	temp+1
	inc	dsp
	bne	1$
	inc	dsp+1

1$:	lda	[dsp],y
	sta	[temp],y
	inc	dsp
	lda	[dsp],y
	iny
	sta	[temp],y
	dey
	inc	dsp
	bne	next2
	inc	dsp+1
	bra	next2
;

code c! ( c c-addr -- )
	lda	[dsp],y
	sta	temp
	inc	dsp
	lda	[dsp],y
	sta	temp+1
	inc	dsp
	bne	1$
	inc	dsp+1

1$:	lda	[dsp],y
	sta	[temp],y
	inc	dsp
	inc	dsp
	bne	next2
	inc	dsp+1
	bra	next2
;

\ code invoke ( addr -- ) \ native code: >r ;
code execute ( addr -- ) \ this version uses token numbers as execution tokens and finds their code address via the headers table
	lda	[dsp],y
	asl	a
	sta	temp
	inc	dsp
	lda	[dsp],y
	rol	a
	tax ; sta temp+1
	inc	dsp
	bne	1$
	inc	dsp+1

1$:	lda	temp
	clc
	adc	#<_head
	sta	temp
	txa ; lda temp+1
	adc	#>_head
	sta	temp+1

	lda	[temp],y
	sta	2$+1 ; self modifying code
	iny
	lda	[temp],y
	sta	2$+2 ; self modifying code
	dey
2$:	jmp	0
;

code branch ( -- )  \ threaded code: r>  @ >r ;
	lda	[ip],y
	tax
	iny
	lda	[ip],y
	dey
	sta	ip+1
	txa
	sta	ip
	bra	next3
;

\ is this misleading? I would have thought ?branch means branch on nonzero
code ?branch ( f -- ) \ threaded code:  ?exit r> @ >r ;
	lda	[dsp],y
	inc	dsp
	ora	[dsp],y
	bne	1$
	inc	dsp
	bne	_branch
	inc	dsp+1
	bra	_branch

1$:	inc	dsp
	bne	2$
	inc	dsp+1
2$:	inc	ip
	bne	3$
	inc	ip+1
3$:	inc	ip
	bne	next3
	inc	ip+1
	bra	next3
;

code depth ( -- n )
	sec
	lda	#<(data_stack + DATA_STACK_SIZE)
	sbc	dsp
	sta	temp
	lda	#>(data_stack + DATA_STACK_SIZE)
	sbc	dsp+1
	lsr	a
	ror	temp

	ldx	dsp
	bne	1$
	dec	dsp+1
1$:	dec	dsp
	sta	[dsp],y
	dec	dsp
	lda	temp
	sta	[dsp],y
	bra	next3
;

code sp@ ( -- x )
	lda	dsp+1
	ldx	dsp
	bne	1$
	dec	dsp+1
1$:	dec	dsp
	sta	[dsp],y
	dec	dsp
	txa
	sta	[dsp],y
	bra	next3
;

code sp! ( x -- )
	lda	[dsp],y
	tax
	iny
	lda	[dsp],y
	dey
	sta	dsp+1
	stx	dsp
	;bra	next3

next3:
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	lda	[ip],y
	sta	2$+1 ; self modifying code
	inc	ip
	bne	1$
	inc	ip+1
1$:	lda	[ip],y
	sta	2$+2 ; self modifying code
	inc	ip
	bne	2$
	inc	ip+1
2$:	jmp	0
;

code rp@ ( -- x )
	ldx	dsp
	bne	1$
	dec	dsp+1
1$:	dec	dsp
	lda	rsp+1
	sta	[dsp],y
	dec	dsp
	lda	rsp
	sta	[dsp],y
	bra	next3
;

code rp! ( x -- )
	lda	[dsp],y
	sta	rsp
	inc	dsp
	lda	[dsp],y
	sta	rsp+1
	inc	dsp
	bne	next3
	inc	dsp+1
	bra	next3
;

code um* ( u1 u2 -- ud )
	sty	temp+4
	sty	temp+5

	lda	[dsp],y
	sta	temp
	iny
	lda	[dsp],y
	sta	temp+1
	iny
	lda	[dsp],y
	sta	temp+2
; tax
	iny
	lda	[dsp],y
	sta	temp+3
; jsr print_hexw
; lda #'*
; jsr print_char
; lda temp+1
; ldx temp
; jsr print_hexw
; lda #'=
; jsr print_char

	ldx	#16
	; cf does not matter here (shift in a random bit that isn't used)
	ror	temp+3
	ror	temp+2
1$:	bcc	2$
	clc
	lda	temp+4
	adc	temp
	sta	temp+4
	lda	temp+5
	adc	temp+1
	sta	temp+5
2$:	ror	temp+5
	ror	temp+4
	ror	temp+3
	ror	temp+2
	dex
	bne	1$
; lda temp+5
; ldx temp+4
; jsr print_hexw
; lda temp+3
; ldx temp+2
; jsr print_hexw
; lda #0xa
; jsr print_char

	lda	temp+3
	sta	[dsp],y
	dey
	lda	temp+2
	sta	[dsp],y
	dey
	lda	temp+5
	sta	[dsp],y
	dey
	lda	temp+4
	sta	[dsp],y

	;bra	next4

next4:
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	lda	[ip],y
	sta	2$+1 ; self modifying code
	inc	ip
	bne	1$
	inc	ip+1
1$:	lda	[ip],y
	sta	2$+2 ; self modifying code
	inc	ip
	bne	2$
	inc	ip+1
2$:	jmp	0
;

code um/mod ( ud u1 -- u2 u3 )
	lda	[dsp],y
	sta	temp
	inc	dsp
	lda	[dsp],y
	sta	temp+1
	inc	dsp
	bne	1$
	inc	dsp+1

1$:	lda	[dsp],y
	sta	temp+4
; tax
	iny
	lda	[dsp],y
	sta	temp+5
; jsr print_hexw
	iny
	lda	[dsp],y
	sta	temp+2
; tax
	iny
	lda	[dsp],y
	sta	temp+3
; jsr print_hexw
; lda #'/
; jsr print_char
; ldx temp
; lda temp+1
; jsr print_hexw
; lda #'=
; jsr print_char

	ldx	#16
	; cf does not matter here (shift in a random bit that isn't used)
	bra	4$
2$:	; shift left has not overflowed, try to subtract divisor
	sec
	lda	temp+4
	sbc	temp
	sta	temp+4
	lda	temp+5
	sbc	temp+1
	sta	temp+5
	bcs	3$ ; went, record 1 in quotient
	lda	temp+4
	adc	temp
	sta	temp+4
	lda	temp+5
	adc	temp+1
	sta	temp+5
	clc ; did not go, record 0 in quotient
3$:	dex
	beq	5$
4$:	; loop entry
	rol	temp+2
	rol	temp+3
	rol	temp+4
	rol	temp+5
	bcc	2$
	; shift left has overflowed, so we can always subtract divisor
	lda	temp+4
	sbc	temp
	sta	temp+4
	lda	temp+5
	sbc	temp+1
	sta	temp+5
	sec ; went, record 1 in quotient
	dex
	bne	4$
5$:	; loop done
	rol	temp+2
	rol	temp+3 ; record final quotient bit
; lda temp+5
; ldx temp+4
; jsr print_hexw
; lda #'r
; jsr print_char
; lda temp+3
; ldx temp+2
; jsr print_hexw
; lda #0xa
; jsr print_char

	lda	temp+5
	sta	[dsp],y
	dey
	lda	temp+4
	sta	[dsp],y
	dey
	lda	temp+3
	sta	[dsp],y
	dey
	lda	temp+2
	sta	[dsp],y

	bra	next5
;

code usleep ( c -- )
	lda	[dsp],y
	sta	USLEEP_LO
	inc	dsp
	lda	[dsp],y
	sta	USLEEP_HI
	inc	dsp
	bne	next5
	inc	dsp+1
	;bra	next5

next5:
; tya
; cmp #0
; beq 5$
; sta SYS_EXIT
;5$:
	lda	[ip],y
	sta	2$+1 ; self modifying code
	inc	ip
	bne	1$
	inc	ip+1
1$:	lda	[ip],y
	sta	2$+2 ; self modifying code
	inc	ip
	bne	2$
	inc	ip+1
2$:	jmp	0

;

\ we want the text section to be first and bss last (for linkers that output
\ sections in definition order), so it would be good to have the bss section
\ be output by the ",end" hook, but at present we cannot call "pre" from a
\ defined word, so we make do by switching to bss and then back to text again
pre
;print_hexw: ; print a:x
;	jsr	print_hexb
;	txa
;print_hexb:
;	pha
;	lsr	a
;	lsr	a
;	lsr	a
;	lsr	a
;	jsr	print_hexn
;	pla
;	and	#0xf
;print_hexn:
;	ora	#'0
;	cmp	#'0 + 10
;	bcc	print_char
;	adc	#'a - '0 - 10 - 1
;print_char:
;	sta	STDERR_DATA
;	rts

	.area	data

	; dictionary pointer: points to	next free location in memory
_dp:	.dw	_mem

	.area	bss

	; head pointer: index of first unused head
__hp:	.ds	2
_head:	.ds	HEAD_SIZE*2

        ; free memory starts at _mem
_mem:	.ds	MEM_SIZE
_memtop:

	.area	text

;
